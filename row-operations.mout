+ autoload ("__fltk_check__", "__init_fltk__.oct");
+ if (__have_feature__ ("FLTK") && __have_feature__ ("OPENGL") && have_window_system ())
+   register_graphics_toolkit ("fltk");
+ endif
+ ## Copyright (C) 2013-2017 John W. Eaton
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {} __have_feature__ (feature)
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ function retval = __have_feature__ (feature)
+ if (strncmp (feature, "ENABLE_", 7))
+   features = __octave_config_info__ ();
+ else
+   features = __octave_config_info__ ("build_features");
+ endif
+ features = __octave_config_info__ ("build_features");
+ if (iscellstr (feature))
+   retval = (all (isfield (features, feature)) && cellfun (@(x) features., feature));
+ elseif (ischar (feature))
+   retval = isfield (features, feature) && features.;
+ else
+   retval = false;
+ endif
+ retval = isfield (features, feature) && features.;
+ endfunction
+ 
+ ## Copyright (C) 2013-2017 John W. Eaton
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {} __have_feature__ (feature)
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ function retval = __have_feature__ (feature)
+ if (strncmp (feature, "ENABLE_", 7))
+   features = __octave_config_info__ ();
+ else
+   features = __octave_config_info__ ("build_features");
+ endif
+ features = __octave_config_info__ ("build_features");
+ if (iscellstr (feature))
+   retval = (all (isfield (features, feature)) && cellfun (@(x) features., feature));
+ elseif (ischar (feature))
+   retval = isfield (features, feature) && features.;
+ else
+   retval = false;
+ endif
+ retval = isfield (features, feature) && features.;
+ endfunction
+ 
+ register_graphics_toolkit ("fltk");
+ autoload ("__have_gnuplot__", "__init_gnuplot__.oct");
+ if (__have_gnuplot__ ())
+   register_graphics_toolkit ("gnuplot");
+ endif
+ ## Copyright (C) 2008-2017 John W. Eaton
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {[@var{prog}, @var{args}] =} gnuplot_binary ()
+ ## @deftypefnx {} {[@var{old_prog}, @var{old_args}] =} gnuplot_binary (@var{new_prog}, @var{arg1}, @dots{})
+ ## Query or set the name of the program invoked by the plot command when the
+ ## graphics toolkit is set to @qcode{"gnuplot"}.
+ ##
+ ## Additional arguments to pass to the external plotting program may also be
+ ## given.  The default value is @qcode{"gnuplot"} with no additional arguments.
+ ## @xref{Installation}.
+ ## @seealso{graphics_toolkit}
+ ## @end deftypefn
+ 
+ ## Author: jwe
+ 
+ function [prog, args] = gnuplot_binary (new_prog, varargin)
+ mlock ()
+ persistent gp_binary = "gnuplot"
+ persistent gp_args = {}(0x0)

+ if (nargout > 0 || nargin == 0)
+   prog = gp_binary;
+   args = gp_args;
+ endif
+ prog = gp_binary;
+ args = gp_args;
+ if (nargin == 1)
+   if (!ischar (new_prog) || isempty (new_prog))
+     error ("gnuplot_binary: NEW_PROG must be a non-empty string");
+   endif
+   gp_binary = new_prog;
+ endif
+ if (nargin > 1)
+   if (!iscellstr (varargin))
+     error ("gnuplot_binary: arguments must be character strings");
+   endif
+   gp_args = varargin;
+ endif
+ endfunction
+ 
+ register_graphics_toolkit ("gnuplot");
+ autoload ("__player_audioplayer__", "audiodevinfo.oct");
+ autoload ("__player_get_channels__", "audiodevinfo.oct");
+ autoload ("__player_get_fs__", "audiodevinfo.oct");
+ autoload ("__player_get_id__", "audiodevinfo.oct");
+ autoload ("__player_get_nbits__", "audiodevinfo.oct");
+ autoload ("__player_get_sample_number__", "audiodevinfo.oct");
+ autoload ("__player_get_tag__", "audiodevinfo.oct");
+ autoload ("__player_get_total_samples__", "audiodevinfo.oct");
+ autoload ("__player_get_userdata__", "audiodevinfo.oct");
+ autoload ("__player_isplaying__", "audiodevinfo.oct");
+ autoload ("__player_pause__", "audiodevinfo.oct");
+ autoload ("__player_play__", "audiodevinfo.oct");
+ autoload ("__player_playblocking__", "audiodevinfo.oct");
+ autoload ("__player_resume__", "audiodevinfo.oct");
+ autoload ("__player_set_fs__", "audiodevinfo.oct");
+ autoload ("__player_set_tag__", "audiodevinfo.oct");
+ autoload ("__player_set_userdata__", "audiodevinfo.oct");
+ autoload ("__player_stop__", "audiodevinfo.oct");
+ autoload ("__recorder_audiorecorder__", "audiodevinfo.oct");
+ autoload ("__recorder_get_channels__", "audiodevinfo.oct");
+ autoload ("__recorder_get_fs__", "audiodevinfo.oct");
+ autoload ("__recorder_get_id__", "audiodevinfo.oct");
+ autoload ("__recorder_get_nbits__", "audiodevinfo.oct");
+ autoload ("__recorder_get_sample_number__", "audiodevinfo.oct");
+ autoload ("__recorder_get_tag__", "audiodevinfo.oct");
+ autoload ("__recorder_get_total_samples__", "audiodevinfo.oct");
+ autoload ("__recorder_get_userdata__", "audiodevinfo.oct");
+ autoload ("__recorder_getaudiodata__", "audiodevinfo.oct");
+ autoload ("__recorder_isrecording__", "audiodevinfo.oct");
+ autoload ("__recorder_pause__", "audiodevinfo.oct");
+ autoload ("__recorder_record__", "audiodevinfo.oct");
+ autoload ("__recorder_recordblocking__", "audiodevinfo.oct");
+ autoload ("__recorder_resume__", "audiodevinfo.oct");
+ autoload ("__recorder_set_fs__", "audiodevinfo.oct");
+ autoload ("__recorder_set_tag__", "audiodevinfo.oct");
+ autoload ("__recorder_set_userdata__", "audiodevinfo.oct");
+ autoload ("__recorder_stop__", "audiodevinfo.oct");
+ autoload ("audioformats", "audioread.oct");
+ autoload ("audioinfo", "audioread.oct");
+ autoload ("audiowrite", "audioread.oct");
+ autoload ("csymamd", "ccolamd.oct");
+ autoload ("chol2inv", "chol.oct");
+ autoload ("choldelete", "chol.oct");
+ autoload ("cholinsert", "chol.oct");
+ autoload ("cholinv", "chol.oct");
+ autoload ("cholshift", "chol.oct");
+ autoload ("cholupdate", "chol.oct");
+ autoload ("etree", "colamd.oct");
+ autoload ("symamd", "colamd.oct");
+ autoload ("sprank", "dmperm.oct");
+ autoload ("bzip2", "gzip.oct");
+ autoload ("qrdelete", "qr.oct");
+ autoload ("qrinsert", "qr.oct");
+ autoload ("qrshift", "qr.oct");
+ autoload ("qrupdate", "qr.oct");
+ endscript
+ ## Discard result to avoid polluting workspace with ans at startup.
+ ~ = __all_opts__ ("fminbnd");
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ ## query all options from all known functions.  These will call optimset,
+ ## which will in turn call us, but we won't answer.
+ recursive = true;
+ names = saved_names;
+ for i = 1:nargin
+   try
+     opts = optimset (varargin {i});
+     fn = fieldnames (opts).';
+     names = [names, fn];
+   catch
+     ## throw the error as a warning.
+     warning (lasterr ());
+   end_try_catch
+ endfor
+ try
+   opts = optimset (varargin {i});
+   fn = fieldnames (opts).';
+   names = [names, fn];
+ catch
+   ## throw the error as a warning.
+   warning (lasterr ());
+ end_try_catch
+ opts = optimset (varargin {i});
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Return defaults for named function.
+ fcn = varargin {1};
+ try
+   retval = feval (fcn, "defaults");
+ catch
+   error ("optimset: no defaults for function '%s'", fcn);
+ end_try_catch
+ retval = feval (fcn, "defaults");
+ ## Copyright (C) 2008-2017 VZLU Prague, a.s.
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ ##
+ ## Author: Jaroslav Hajek <highegg@gmail.com>
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fminbnd (@var{fun}, @var{a}, @var{b}, @var{options})
+ ## Find a minimum point of a univariate function.
+ ##
+ ## @var{fun} should be a function handle or name.  @var{a}, @var{b} specify a
+ ## starting interval.  @var{options} is a structure specifying additional
+ ## options.  Currently, @code{fminbnd} recognizes these options:
+ ## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
+ ## @qcode{"MaxIter"}, @qcode{"MaxFunEvals"}.  For a description of these
+ ## options, see @ref{XREFoptimset,,optimset}.
+ ##
+ ## On exit, the function returns @var{x}, the approximate minimum point and
+ ## @var{fval}, the function value thereof.
+ ##
+ ## @var{info} is an exit flag that can have these values:
+ ##
+ ## @itemize
+ ## @item 1
+ ## The algorithm converged to a solution.
+ ##
+ ## @item 0
+ ## Maximum number of iterations or function evaluations has been exhausted.
+ ##
+ ## @item -1
+ ## The algorithm has been terminated from user output function.
+ ## @end itemize
+ ##
+ ## Notes: The search for a minimum is restricted to be in the interval bound by
+ ## @var{a} and @var{b}.  If you only have an initial point to begin searching
+ ## from you will need to use an unconstrained minimization algorithm such as
+ ## @code{fminunc} or @code{fminsearch}.  @code{fminbnd} internally uses a
+ ## Golden Section search strategy.
+ ## @seealso{fzero, fminunc, fminsearch, optimset}
+ ## @end deftypefn
+ 
+ ## This is patterned after opt/fmin.f from Netlib, which in turn is taken from
+ ## Richard Brent: Algorithms For Minimization Without Derivatives,
+ ## Prentice-Hall (1973)
+ 
+ ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+ ## PKG_ADD: [~] = __all_opts__ ("fminbnd");
+ 
+ function [x, fval, info, output] = fminbnd (fun, xmin, xmax, options = struct ())
+ ## Get default options if requested.
+ if (nargin == 1 && ischar (fun) && strcmp (fun, 'defaults'))
+   x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8, "OutputFcn", [], "FunValCheck", "off");
+   return
+ endif
+ x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8, "OutputFcn", [], "FunValCheck", "off");
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Create struct.
+ ## Default values are replaced by those specified by name/value pairs.
+ pairs = reshape (varargin, 2, []);
+ retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Set slots in old from non-empties in new.
+ ## Should we be checking to ensure that the field names are expected?
+ old = varargin {1};
+ new = varargin {2};
+ fnames = fieldnames (old);
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ ## skip validation if we're in the internal query
+ validation = !isempty (opts);
+ for [val, key] = new
+   if (validation)
+     ## Case insensitive lookup in all options.
+     i = strncmpi (opts, key, length (key));
+     nmatch = sum (i);
+     ## Validate option.
+     if (nmatch == 1)
+       key = opts {find (i)};
+     elseif (nmatch == 0)
+       warning ("optimset: unrecognized option: %s", key);
+     else
+       fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+       warning (fmt, key, opts {i});
+     endif
+   endif
+   old. = val;
+ endfor
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ retval = old;
+ endfunction
+ 
+ endfunction
+ 
+ return
+ 
+ endfunction
+ 
+ fn = fieldnames (opts).';
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ names = [names, fn];
+ names = unique (names);
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ y = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ endfunction
+ 
+ [lnames, idx] = unique (tolower (names));
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ [y, i] = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ idx = find (match);
+ if (optfirst)
+   idx += 1;
+   ## in-place is faster than other forms of increment
+ endif
+ i (idx) = [];
+ endfunction
+ 
+ if (length (lnames) < length (names))
+   ## This is bad.
+   error ("__all_opts__: duplicate options with inconsistent case");
+ else
+   names = names (idx);
+ endif
+ names = names (idx);
+ saved_names = names;
+ recursive = false;
+ endfunction
+ 
+ ## Discard result to avoid polluting workspace with ans at startup.
+ ~ = __all_opts__ ("fminsearch");
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ ## query all options from all known functions.  These will call optimset,
+ ## which will in turn call us, but we won't answer.
+ recursive = true;
+ names = saved_names;
+ for i = 1:nargin
+   try
+     opts = optimset (varargin {i});
+     fn = fieldnames (opts).';
+     names = [names, fn];
+   catch
+     ## throw the error as a warning.
+     warning (lasterr ());
+   end_try_catch
+ endfor
+ try
+   opts = optimset (varargin {i});
+   fn = fieldnames (opts).';
+   names = [names, fn];
+ catch
+   ## throw the error as a warning.
+   warning (lasterr ());
+ end_try_catch
+ opts = optimset (varargin {i});
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Return defaults for named function.
+ fcn = varargin {1};
+ try
+   retval = feval (fcn, "defaults");
+ catch
+   error ("optimset: no defaults for function '%s'", fcn);
+ end_try_catch
+ retval = feval (fcn, "defaults");
+ ## Copyright (C) 2003-2017 Andy Adler
+ ## Copyright (C) 2002, 2013 N.J.Higham
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{x} =} fminsearch (@var{fun}, @var{x0})
+ ## @deftypefnx {} {@var{x} =} fminsearch (@var{fun}, @var{x0}, @var{options})
+ ## @deftypefnx {} {[@var{x}, @var{fval}] =} fminsearch (@dots{})
+ ##
+ ## Find a value of @var{x} which minimizes the function @var{fun}.
+ ##
+ ## The search begins at the point @var{x0} and iterates using the
+ ## @nospell{Nelder & Mead} Simplex algorithm (a derivative-free method).  This
+ ## algorithm is better-suited to functions which have discontinuities or for
+ ## which a gradient-based search such as @code{fminunc} fails.
+ ##
+ ## Options for the search are provided in the parameter @var{options} using the
+ ## function @code{optimset}.  Currently, @code{fminsearch} accepts the options:
+ ## @qcode{"TolX"}, @qcode{"MaxFunEvals"}, @qcode{"MaxIter"}, @qcode{"Display"}.
+ ## For a description of these options, see @code{optimset}.
+ ##
+ ## On exit, the function returns @var{x}, the minimum point, and @var{fval},
+ ## the function value thereof.
+ ##
+ ## Example usages:
+ ##
+ ## @example
+ ## @group
+ ## fminsearch (@@(x) (x(1)-5).^2+(x(2)-8).^4, [0;0])
+ ##
+ ## fminsearch (inline ("(x(1)-5).^2+(x(2)-8).^4", "x"), [0;0])
+ ## @end group
+ ## @end example
+ ## @seealso{fminbnd, fminunc, optimset}
+ ## @end deftypefn
+ 
+ ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+ ## PKG_ADD: [~] = __all_opts__ ("fminsearch");
+ 
+ ## FIXME: Add support for "exitflag" output variable.
+ ## FIXME: Add support for "output" output variable.
+ ## FIXME: For Display option, add 'final' and 'notify' options.  Not too hard.
+ ## FIXME: Add support for OutputFcn.  See fminunc for a template.
+ ## FIXME: Add support for exiting based on TolFun.  See fminunc for an idea.
+ 
+ function [x, fval] = fminsearch (fun, x0, options = struct ())
+ ## Get default options if requested.
+ if (nargin == 1 && ischar (fun) && strcmp (fun, "defaults"))
+   x = optimset ("Display", "notify", "FunValCheck", "off", "MaxFunEvals", 400, "MaxIter", 400, "OutputFcn", [], "TolFun", 1e-7, "TolX", 1e-4);
+   return
+ endif
+ x = optimset ("Display", "notify", "FunValCheck", "off", "MaxFunEvals", 400, "MaxIter", 400, "OutputFcn", [], "TolFun", 1e-7, "TolX", 1e-4);
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Create struct.
+ ## Default values are replaced by those specified by name/value pairs.
+ pairs = reshape (varargin, 2, []);
+ retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Set slots in old from non-empties in new.
+ ## Should we be checking to ensure that the field names are expected?
+ old = varargin {1};
+ new = varargin {2};
+ fnames = fieldnames (old);
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ ## skip validation if we're in the internal query
+ validation = !isempty (opts);
+ for [val, key] = new
+   if (validation)
+     ## Case insensitive lookup in all options.
+     i = strncmpi (opts, key, length (key));
+     nmatch = sum (i);
+     ## Validate option.
+     if (nmatch == 1)
+       key = opts {find (i)};
+     elseif (nmatch == 0)
+       warning ("optimset: unrecognized option: %s", key);
+     else
+       fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+       warning (fmt, key, opts {i});
+     endif
+   endif
+   old. = val;
+ endfor
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ retval = old;
+ endfunction
+ 
+ endfunction
+ 
+ return
+ 
+ endfunction
+ 
+ fn = fieldnames (opts).';
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ names = [names, fn];
+ names = unique (names);
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ y = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ endfunction
+ 
+ [lnames, idx] = unique (tolower (names));
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ [y, i] = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ idx = find (match);
+ if (optfirst)
+   idx += 1;
+   ## in-place is faster than other forms of increment
+ endif
+ i (idx) = [];
+ endfunction
+ 
+ if (length (lnames) < length (names))
+   ## This is bad.
+   error ("__all_opts__: duplicate options with inconsistent case");
+ else
+   names = names (idx);
+ endif
+ names = names (idx);
+ saved_names = names;
+ recursive = false;
+ endfunction
+ 
+ ## Discard result to avoid polluting workspace with ans at startup.
+ ~ = __all_opts__ ("fminunc");
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ ## query all options from all known functions.  These will call optimset,
+ ## which will in turn call us, but we won't answer.
+ recursive = true;
+ names = saved_names;
+ for i = 1:nargin
+   try
+     opts = optimset (varargin {i});
+     fn = fieldnames (opts).';
+     names = [names, fn];
+   catch
+     ## throw the error as a warning.
+     warning (lasterr ());
+   end_try_catch
+ endfor
+ try
+   opts = optimset (varargin {i});
+   fn = fieldnames (opts).';
+   names = [names, fn];
+ catch
+   ## throw the error as a warning.
+   warning (lasterr ());
+ end_try_catch
+ opts = optimset (varargin {i});
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Return defaults for named function.
+ fcn = varargin {1};
+ try
+   retval = feval (fcn, "defaults");
+ catch
+   error ("optimset: no defaults for function '%s'", fcn);
+ end_try_catch
+ retval = feval (fcn, "defaults");
+ ## Copyright (C) 2008-2017 VZLU Prague, a.s.
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ ##
+ ## Author: Jaroslav Hajek <highegg@gmail.com>
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} fminunc (@var{fcn}, @var{x0})
+ ## @deftypefnx {} {} fminunc (@var{fcn}, @var{x0}, @var{options})
+ ## @deftypefnx {} {[@var{x}, @var{fval}, @var{info}, @var{output}, @var{grad}, @var{hess}] =} fminunc (@var{fcn}, @dots{})
+ ## Solve an unconstrained optimization problem defined by the function
+ ## @var{fcn}.
+ ##
+ ## @var{fcn} should accept a vector (array) defining the unknown variables, and
+ ## return the objective function value, optionally with gradient.
+ ## @code{fminunc} attempts to determine a vector @var{x} such that
+ ## @code{@var{fcn} (@var{x})} is a local minimum.
+ ##
+ ## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved in
+ ## all calls to @var{fcn}, but otherwise is treated as a column vector.
+ ##
+ ## @var{options} is a structure specifying additional options.  Currently,
+ ## @code{fminunc} recognizes these options:
+ ## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
+ ## @qcode{"TolFun"}, @qcode{"MaxIter"}, @qcode{"MaxFunEvals"},
+ ## @qcode{"GradObj"}, @qcode{"FinDiffType"}, @qcode{"TypicalX"},
+ ## @qcode{"AutoScaling"}.
+ ##
+ ## If @qcode{"GradObj"} is @qcode{"on"}, it specifies that @var{fcn}, when
+ ## called with two output arguments, also returns the Jacobian matrix of
+ ## partial first derivatives at the requested point.  @code{TolX} specifies
+ ## the termination tolerance for the unknown variables @var{x}, while
+ ## @code{TolFun} is a tolerance for the objective function value @var{fval}.
+ ##  The default is @code{1e-7} for both options.
+ ##
+ ## For a description of the other options, see @code{optimset}.
+ ##
+ ## On return, @var{x} is the location of the minimum and @var{fval} contains
+ ## the value of the objective function at @var{x}.
+ ##
+ ## @var{info} may be one of the following values:
+ ##
+ ## @table @asis
+ ## @item 1
+ ## Converged to a solution point.  Relative gradient error is less than
+ ## specified by @code{TolFun}.
+ ##
+ ## @item 2
+ ## Last relative step size was less than @code{TolX}.
+ ##
+ ## @item 3
+ ## Last relative change in function value was less than @code{TolFun}.
+ ##
+ ## @item 0
+ ## Iteration limit exceeded---either maximum number of algorithm iterations
+ ## @code{MaxIter} or maximum number of function evaluations @code{MaxFunEvals}.
+ ##
+ ## @item -1
+ ## Algorithm terminated by @code{OutputFcn}.
+ ##
+ ## @item -3
+ ## The trust region radius became excessively small.
+ ## @end table
+ ##
+ ## Optionally, @code{fminunc} can return a structure with convergence
+ ## statistics (@var{output}), the output gradient (@var{grad}) at the
+ ## solution @var{x}, and approximate Hessian (@var{hess}) at the solution
+ ## @var{x}.
+ ##
+ ## Application Notes: If the objective function is a single nonlinear equation
+ ## of one variable then using @code{fminbnd} is usually a better choice.
+ ##
+ ## The algorithm used by @code{fminunc} is a gradient search which depends
+ ## on the objective function being differentiable.  If the function has
+ ## discontinuities it may be better to use a derivative-free algorithm such as
+ ## @code{fminsearch}.
+ ## @seealso{fminbnd, fminsearch, optimset}
+ ## @end deftypefn
+ 
+ ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+ ## PKG_ADD: [~] = __all_opts__ ("fminunc");
+ 
+ function [x, fval, info, output, grad, hess] = fminunc (fcn, x0, options = struct ())
+ ## Get default options if requested.
+ if (nargin == 1 && strcmp (fcn, "defaults"))
+   x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, "GradObj", "off", "TolX", 1e-7, "TolFun", 1e-7, "OutputFcn", [], "FunValCheck", "off", "FinDiffType", "central", "TypicalX", [], "AutoScaling", "off");
+   return
+ endif
+ x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, "GradObj", "off", "TolX", 1e-7, "TolFun", 1e-7, "OutputFcn", [], "FunValCheck", "off", "FinDiffType", "central", "TypicalX", [], "AutoScaling", "off");
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Create struct.
+ ## Default values are replaced by those specified by name/value pairs.
+ pairs = reshape (varargin, 2, []);
+ retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Set slots in old from non-empties in new.
+ ## Should we be checking to ensure that the field names are expected?
+ old = varargin {1};
+ new = varargin {2};
+ fnames = fieldnames (old);
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ ## skip validation if we're in the internal query
+ validation = !isempty (opts);
+ for [val, key] = new
+   if (validation)
+     ## Case insensitive lookup in all options.
+     i = strncmpi (opts, key, length (key));
+     nmatch = sum (i);
+     ## Validate option.
+     if (nmatch == 1)
+       key = opts {find (i)};
+     elseif (nmatch == 0)
+       warning ("optimset: unrecognized option: %s", key);
+     else
+       fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+       warning (fmt, key, opts {i});
+     endif
+   endif
+   old. = val;
+ endfor
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ retval = old;
+ endfunction
+ 
+ endfunction
+ 
+ return
+ 
+ endfunction
+ 
+ fn = fieldnames (opts).';
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ names = [names, fn];
+ names = unique (names);
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ y = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ endfunction
+ 
+ [lnames, idx] = unique (tolower (names));
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ [y, i] = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ idx = find (match);
+ if (optfirst)
+   idx += 1;
+   ## in-place is faster than other forms of increment
+ endif
+ i (idx) = [];
+ endfunction
+ 
+ if (length (lnames) < length (names))
+   ## This is bad.
+   error ("__all_opts__: duplicate options with inconsistent case");
+ else
+   names = names (idx);
+ endif
+ names = names (idx);
+ saved_names = names;
+ recursive = false;
+ endfunction
+ 
+ ## Discard result to avoid polluting workspace with ans at startup.
+ ~ = __all_opts__ ("fsolve");
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ ## query all options from all known functions.  These will call optimset,
+ ## which will in turn call us, but we won't answer.
+ recursive = true;
+ names = saved_names;
+ for i = 1:nargin
+   try
+     opts = optimset (varargin {i});
+     fn = fieldnames (opts).';
+     names = [names, fn];
+   catch
+     ## throw the error as a warning.
+     warning (lasterr ());
+   end_try_catch
+ endfor
+ try
+   opts = optimset (varargin {i});
+   fn = fieldnames (opts).';
+   names = [names, fn];
+ catch
+   ## throw the error as a warning.
+   warning (lasterr ());
+ end_try_catch
+ opts = optimset (varargin {i});
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Return defaults for named function.
+ fcn = varargin {1};
+ try
+   retval = feval (fcn, "defaults");
+ catch
+   error ("optimset: no defaults for function '%s'", fcn);
+ end_try_catch
+ retval = feval (fcn, "defaults");
+ ## Copyright (C) 2008-2017 VZLU Prague, a.s.
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ ##
+ ## Author: Jaroslav Hajek <highegg@gmail.com>
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} fsolve (@var{fcn}, @var{x0}, @var{options})
+ ## @deftypefnx {} {[@var{x}, @var{fvec}, @var{info}, @var{output}, @var{fjac}] =} fsolve (@var{fcn}, @dots{})
+ ## Solve a system of nonlinear equations defined by the function @var{fcn}.
+ ##
+ ## @var{fcn} should accept a vector (array) defining the unknown variables,
+ ## and return a vector of left-hand sides of the equations.  Right-hand sides
+ ## are defined to be zeros.  In other words, this function attempts to
+ ## determine a vector @var{x} such that @code{@var{fcn} (@var{x})} gives
+ ## (approximately) all zeros.
+ ##
+ ## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
+ ## in all calls to @var{fcn}, but otherwise it is treated as a column vector.
+ ##
+ ## @var{options} is a structure specifying additional options.  Currently,
+ ## @code{fsolve} recognizes these options:
+ ## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
+ ## @qcode{"TolFun"}, @qcode{"MaxIter"}, @qcode{"MaxFunEvals"},
+ ## @qcode{"Jacobian"}, @qcode{"Updating"}, @qcode{"ComplexEqn"}
+ ## @qcode{"TypicalX"}, @qcode{"AutoScaling"} and @qcode{"FinDiffType"}.
+ ##
+ ## If @qcode{"Jacobian"} is @qcode{"on"}, it specifies that @var{fcn}, called
+ ## with 2 output arguments also returns the Jacobian matrix of right-hand sides
+ ## at the requested point.  @qcode{"TolX"} specifies the termination tolerance
+ ## in the unknown variables, while @qcode{"TolFun"} is a tolerance for
+ ## equations.  Default is @code{1e-7} for both @qcode{"TolX"} and
+ ## @qcode{"TolFun"}.
+ ##
+ ## If @qcode{"AutoScaling"} is on, the variables will be automatically scaled
+ ## according to the column norms of the (estimated) Jacobian.  As a result,
+ ## TolF becomes scaling-independent.  By default, this option is off because
+ ## it may sometimes deliver unexpected (though mathematically correct) results.
+ ##
+ ## If @qcode{"Updating"} is @qcode{"on"}, the function will attempt to use
+ ## @nospell{Broyden} updates to update the Jacobian, in order to reduce the
+ ## amount of Jacobian calculations.  If your user function always calculates
+ ## the Jacobian (regardless of number of output arguments) then this option
+ ## provides no advantage and should be set to false.
+ ##
+ ## @qcode{"ComplexEqn"} is @qcode{"on"}, @code{fsolve} will attempt to solve
+ ## complex equations in complex variables, assuming that the equations possess
+ ## a complex derivative (i.e., are holomorphic).  If this is not what you want,
+ ## you should unpack the real and imaginary parts of the system to get a real
+ ## system.
+ ##
+ ## For description of the other options, see @code{optimset}.
+ ##
+ ## On return, @var{fval} contains the value of the function @var{fcn}
+ ## evaluated at @var{x}.
+ ##
+ ## @var{info} may be one of the following values:
+ ##
+ ## @table @asis
+ ## @item 1
+ ## Converged to a solution point.  Relative residual error is less than
+ ## specified by TolFun.
+ ##
+ ## @item 2
+ ## Last relative step size was less that TolX.
+ ##
+ ## @item 3
+ ## Last relative decrease in residual was less than TolF.
+ ##
+ ## @item 0
+ ## Iteration limit exceeded.
+ ##
+ ## @item -3
+ ## The trust region radius became excessively small.
+ ## @end table
+ ##
+ ## Note: If you only have a single nonlinear equation of one variable, using
+ ## @code{fzero} is usually a much better idea.
+ ##
+ ## Note about user-supplied Jacobians:
+ ## As an inherent property of the algorithm, a Jacobian is always requested for
+ ## a solution vector whose residual vector is already known, and it is the last
+ ## accepted successful step.  Often this will be one of the last two calls, but
+ ## not always.  If the savings by reusing intermediate results from residual
+ ## calculation in Jacobian calculation are significant, the best strategy is to
+ ## employ OutputFcn: After a vector is evaluated for residuals, if OutputFcn is
+ ## called with that vector, then the intermediate results should be saved for
+ ## future Jacobian evaluation, and should be kept until a Jacobian evaluation
+ ## is requested or until OutputFcn is called with a different vector, in which
+ ## case they should be dropped in favor of this most recent vector.  A short
+ ## example how this can be achieved follows:
+ ##
+ ## @example
+ ## function [fvec, fjac] = user_func (x, optimvalues, state)
+ ## persistent sav = [], sav0 = [];
+ ## if (nargin == 1)
+ ##   ## evaluation call
+ ##   if (nargout == 1)
+ ##     sav0.x = x; # mark saved vector
+ ##     ## calculate fvec, save results to sav0.
+ ##   elseif (nargout == 2)
+ ##     ## calculate fjac using sav.
+ ##   endif
+ ## else
+ ##   ## outputfcn call.
+ ##   if (all (x == sav0.x))
+ ##     sav = sav0;
+ ##   endif
+ ##   ## maybe output iteration status, etc.
+ ## endif
+ ## endfunction
+ ##
+ ## ## @dots{}
+ ##
+ ## fsolve (@@user_func, x0, optimset ("OutputFcn", @@user_func, @dots{}))
+ ## @end example
+ ## @seealso{fzero, optimset}
+ ## @end deftypefn
+ 
+ ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+ ## PKG_ADD: [~] = __all_opts__ ("fsolve");
+ 
+ function [x, fvec, info, output, fjac] = fsolve (fcn, x0, options = struct ())
+ ## Get default options if requested.
+ if (nargin == 1 && ischar (fcn) && strcmp (fcn, 'defaults'))
+   x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, "Jacobian", "off", "TolX", 1e-7, "TolFun", 1e-7, "OutputFcn", [], "Updating", "on", "FunValCheck", "off", "ComplexEqn", "off", "FinDiffType", "central", "TypicalX", [], "AutoScaling", "off");
+   return
+ endif
+ x = optimset ("MaxIter", 400, "MaxFunEvals", Inf, "Jacobian", "off", "TolX", 1e-7, "TolFun", 1e-7, "OutputFcn", [], "Updating", "on", "FunValCheck", "off", "ComplexEqn", "off", "FinDiffType", "central", "TypicalX", [], "AutoScaling", "off");
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Create struct.
+ ## Default values are replaced by those specified by name/value pairs.
+ pairs = reshape (varargin, 2, []);
+ retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Set slots in old from non-empties in new.
+ ## Should we be checking to ensure that the field names are expected?
+ old = varargin {1};
+ new = varargin {2};
+ fnames = fieldnames (old);
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ ## skip validation if we're in the internal query
+ validation = !isempty (opts);
+ for [val, key] = new
+   if (validation)
+     ## Case insensitive lookup in all options.
+     i = strncmpi (opts, key, length (key));
+     nmatch = sum (i);
+     ## Validate option.
+     if (nmatch == 1)
+       key = opts {find (i)};
+     elseif (nmatch == 0)
+       warning ("optimset: unrecognized option: %s", key);
+     else
+       fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+       warning (fmt, key, opts {i});
+     endif
+   endif
+   old. = val;
+ endfor
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ retval = old;
+ endfunction
+ 
+ endfunction
+ 
+ return
+ 
+ endfunction
+ 
+ fn = fieldnames (opts).';
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ names = [names, fn];
+ names = unique (names);
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ y = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ endfunction
+ 
+ [lnames, idx] = unique (tolower (names));
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ [y, i] = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ idx = find (match);
+ if (optfirst)
+   idx += 1;
+   ## in-place is faster than other forms of increment
+ endif
+ i (idx) = [];
+ endfunction
+ 
+ if (length (lnames) < length (names))
+   ## This is bad.
+   error ("__all_opts__: duplicate options with inconsistent case");
+ else
+   names = names (idx);
+ endif
+ names = names (idx);
+ saved_names = names;
+ recursive = false;
+ endfunction
+ 
+ ## Discard result to avoid polluting workspace with ans at startup.
+ ~ = __all_opts__ ("fzero");
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ ## query all options from all known functions.  These will call optimset,
+ ## which will in turn call us, but we won't answer.
+ recursive = true;
+ names = saved_names;
+ for i = 1:nargin
+   try
+     opts = optimset (varargin {i});
+     fn = fieldnames (opts).';
+     names = [names, fn];
+   catch
+     ## throw the error as a warning.
+     warning (lasterr ());
+   end_try_catch
+ endfor
+ try
+   opts = optimset (varargin {i});
+   fn = fieldnames (opts).';
+   names = [names, fn];
+ catch
+   ## throw the error as a warning.
+   warning (lasterr ());
+ end_try_catch
+ opts = optimset (varargin {i});
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Return defaults for named function.
+ fcn = varargin {1};
+ try
+   retval = feval (fcn, "defaults");
+ catch
+   error ("optimset: no defaults for function '%s'", fcn);
+ end_try_catch
+ retval = feval (fcn, "defaults");
+ ## Copyright (C) 2008-2017 VZLU Prague, a.s.
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ ##
+ ## Author: Jaroslav Hajek <highegg@gmail.com>
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} fzero (@var{fun}, @var{x0})
+ ## @deftypefnx {} {} fzero (@var{fun}, @var{x0}, @var{options})
+ ## @deftypefnx {} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fzero (@dots{})
+ ## Find a zero of a univariate function.
+ ##
+ ## @var{fun} is a function handle, inline function, or string containing the
+ ## name of the function to evaluate.
+ ##
+ ## @var{x0} should be a two-element vector specifying two points which
+ ## bracket a zero.  In other words, there must be a change in sign of the
+ ## function between @var{x0}(1) and @var{x0}(2).  More mathematically, the
+ ## following must hold
+ ##
+ ## @example
+ ## sign (@var{fun}(@var{x0}(1))) * sign (@var{fun}(@var{x0}(2))) <= 0
+ ## @end example
+ ##
+ ## If @var{x0} is a single scalar then several nearby and distant values are
+ ## probed in an attempt to obtain a valid bracketing.  If this is not
+ ## successful, the function fails.
+ ##
+ ## @var{options} is a structure specifying additional options.  Currently,
+ ## @code{fzero} recognizes these options:
+ ## @qcode{"FunValCheck"}, @qcode{"OutputFcn"}, @qcode{"TolX"},
+ ## @qcode{"MaxIter"}, @qcode{"MaxFunEvals"}.
+ ## For a description of these options, see @ref{XREFoptimset,,optimset}.
+ ##
+ ## On exit, the function returns @var{x}, the approximate zero point and
+ ## @var{fval}, the function value thereof.
+ ##
+ ## @var{info} is an exit flag that can have these values:
+ ##
+ ## @itemize
+ ## @item 1
+ ##  The algorithm converged to a solution.
+ ##
+ ## @item 0
+ ##  Maximum number of iterations or function evaluations has been reached.
+ ##
+ ## @item -1
+ ## The algorithm has been terminated from user output function.
+ ##
+ ## @item -5
+ ## The algorithm may have converged to a singular point.
+ ## @end itemize
+ ##
+ ## @var{output} is a structure containing runtime information about the
+ ## @code{fzero} algorithm.  Fields in the structure are:
+ ##
+ ## @itemize
+ ## @item iterations
+ ##  Number of iterations through loop.
+ ##
+ ## @item nfev
+ ##  Number of function evaluations.
+ ##
+ ## @item bracketx
+ ##  A two-element vector with the final bracketing of the zero along the
+ ## x-axis.
+ ##
+ ## @item brackety
+ ##  A two-element vector with the final bracketing of the zero along the
+ ## y-axis.
+ ## @end itemize
+ ## @seealso{optimset, fsolve}
+ ## @end deftypefn
+ 
+ ## This is essentially the ACM algorithm 748: Enclosing Zeros of
+ ## Continuous Functions due to Alefeld, Potra and Shi, ACM Transactions
+ ## on Mathematical Software, Vol. 21, No. 3, September 1995. Although
+ ## the workflow should be the same, the structure of the algorithm has
+ ## been transformed non-trivially; instead of the authors' approach of
+ ## sequentially calling building blocks subprograms we implement here a
+ ## FSM version using one interior point determination and one bracketing
+ ## per iteration, thus reducing the number of temporary variables and
+ ## simplifying the algorithm structure.  Further, this approach reduces
+ ## the need for external functions and error handling.  The algorithm has
+ ## also been slightly modified.
+ 
+ ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+ ## PKG_ADD: [~] = __all_opts__ ("fzero");
+ 
+ function [x, fval, info, output] = fzero (fun, x0, options = struct ())
+ ## Get default options if requested.
+ if (nargin == 1 && ischar (fun) && strcmp (fun, 'defaults'))
+   x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", eps, "OutputFcn", [], "FunValCheck", "off");
+   return
+ endif
+ x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", eps, "OutputFcn", [], "FunValCheck", "off");
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Create struct.
+ ## Default values are replaced by those specified by name/value pairs.
+ pairs = reshape (varargin, 2, []);
+ retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Set slots in old from non-empties in new.
+ ## Should we be checking to ensure that the field names are expected?
+ old = varargin {1};
+ new = varargin {2};
+ fnames = fieldnames (old);
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ ## skip validation if we're in the internal query
+ validation = !isempty (opts);
+ for [val, key] = new
+   if (validation)
+     ## Case insensitive lookup in all options.
+     i = strncmpi (opts, key, length (key));
+     nmatch = sum (i);
+     ## Validate option.
+     if (nmatch == 1)
+       key = opts {find (i)};
+     elseif (nmatch == 0)
+       warning ("optimset: unrecognized option: %s", key);
+     else
+       fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+       warning (fmt, key, opts {i});
+     endif
+   endif
+   old. = val;
+ endfor
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ retval = old;
+ endfunction
+ 
+ endfunction
+ 
+ return
+ 
+ endfunction
+ 
+ fn = fieldnames (opts).';
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ names = [names, fn];
+ names = unique (names);
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ y = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ endfunction
+ 
+ [lnames, idx] = unique (tolower (names));
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ [y, i] = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ idx = find (match);
+ if (optfirst)
+   idx += 1;
+   ## in-place is faster than other forms of increment
+ endif
+ i (idx) = [];
+ endfunction
+ 
+ if (length (lnames) < length (names))
+   ## This is bad.
+   error ("__all_opts__: duplicate options with inconsistent case");
+ else
+   names = names (idx);
+ endif
+ names = names (idx);
+ saved_names = names;
+ recursive = false;
+ endfunction
+ 
+ ## Discard result to avoid polluting workspace with ans at startup.
+ ~ = __all_opts__ ("lsqnonneg");
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ ## query all options from all known functions.  These will call optimset,
+ ## which will in turn call us, but we won't answer.
+ recursive = true;
+ names = saved_names;
+ for i = 1:nargin
+   try
+     opts = optimset (varargin {i});
+     fn = fieldnames (opts).';
+     names = [names, fn];
+   catch
+     ## throw the error as a warning.
+     warning (lasterr ());
+   end_try_catch
+ endfor
+ try
+   opts = optimset (varargin {i});
+   fn = fieldnames (opts).';
+   names = [names, fn];
+ catch
+   ## throw the error as a warning.
+   warning (lasterr ());
+ end_try_catch
+ opts = optimset (varargin {i});
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Return defaults for named function.
+ fcn = varargin {1};
+ try
+   retval = feval (fcn, "defaults");
+ catch
+   error ("optimset: no defaults for function '%s'", fcn);
+ end_try_catch
+ retval = feval (fcn, "defaults");
+ ## Copyright (C) 2008-2017 Bill Denney
+ ## Copyright (C) 2008 Jaroslav Hajek
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{x} =} lsqnonneg (@var{c}, @var{d})
+ ## @deftypefnx {} {@var{x} =} lsqnonneg (@var{c}, @var{d}, @var{x0})
+ ## @deftypefnx {} {@var{x} =} lsqnonneg (@var{c}, @var{d}, @var{x0}, @var{options})
+ ## @deftypefnx {} {[@var{x}, @var{resnorm}] =} lsqnonneg (@dots{})
+ ## @deftypefnx {} {[@var{x}, @var{resnorm}, @var{residual}] =} lsqnonneg (@dots{})
+ ## @deftypefnx {} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}] =} lsqnonneg (@dots{})
+ ## @deftypefnx {} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}] =} lsqnonneg (@dots{})
+ ## @deftypefnx {} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}, @var{lambda}] =} lsqnonneg (@dots{})
+ ## Minimize @code{norm (@var{c}*@var{x} - d)} subject to
+ ## @code{@var{x} >= 0}.
+ ##
+ ## @var{c} and @var{d} must be real.
+ ##
+ ## @var{x0} is an optional initial guess for @var{x}.
+ ##
+ ## Currently, @code{lsqnonneg} recognizes these options: @qcode{"MaxIter"},
+ ## @qcode{"TolX"}.  For a description of these options, see
+ ## @ref{XREFoptimset,,optimset}.
+ ##
+ ## Outputs:
+ ##
+ ## @itemize @bullet
+ ## @item resnorm
+ ##
+ ## The squared 2-norm of the residual: norm (@var{c}*@var{x}-@var{d})^2
+ ##
+ ## @item residual
+ ##
+ ## The residual: @var{d}-@var{c}*@var{x}
+ ##
+ ## @item exitflag
+ ##
+ ## An indicator of convergence.  0 indicates that the iteration count was
+ ## exceeded, and therefore convergence was not reached; >0 indicates that the
+ ## algorithm converged.  (The algorithm is stable and will converge given
+ ## enough iterations.)
+ ##
+ ## @item output
+ ##
+ ## A structure with two fields:
+ ##
+ ## @itemize @bullet
+ ## @item @qcode{"algorithm"}: The algorithm used (@qcode{"nnls"})
+ ##
+ ## @item @qcode{"iterations"}: The number of iterations taken.
+ ## @end itemize
+ ##
+ ## @item lambda
+ ##
+ ## Not implemented.
+ ## @end itemize
+ ## @seealso{optimset, pqpnonneg, lscov}
+ ## @end deftypefn
+ 
+ ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+ ## PKG_ADD: [~] = __all_opts__ ("lsqnonneg");
+ 
+ ## This is implemented from Lawson and Hanson's 1973 algorithm on page
+ ## 161 of Solving Least Squares Problems.
+ 
+ function [x, resnorm, residual, exitflag, output, lambda] = lsqnonneg (c, d, x = [], options = struct ())
+ if (nargin == 1 && ischar (c) && strcmp (c, 'defaults'))
+   x = optimset ("MaxIter", 1e5);
+   return
+ endif
+ x = optimset ("MaxIter", 1e5);
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Create struct.
+ ## Default values are replaced by those specified by name/value pairs.
+ pairs = reshape (varargin, 2, []);
+ retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Set slots in old from non-empties in new.
+ ## Should we be checking to ensure that the field names are expected?
+ old = varargin {1};
+ new = varargin {2};
+ fnames = fieldnames (old);
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ ## skip validation if we're in the internal query
+ validation = !isempty (opts);
+ for [val, key] = new
+   if (validation)
+     ## Case insensitive lookup in all options.
+     i = strncmpi (opts, key, length (key));
+     nmatch = sum (i);
+     ## Validate option.
+     if (nmatch == 1)
+       key = opts {find (i)};
+     elseif (nmatch == 0)
+       warning ("optimset: unrecognized option: %s", key);
+     else
+       fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+       warning (fmt, key, opts {i});
+     endif
+   endif
+   old. = val;
+ endfor
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ retval = old;
+ endfunction
+ 
+ endfunction
+ 
+ return
+ 
+ endfunction
+ 
+ fn = fieldnames (opts).';
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ names = [names, fn];
+ names = unique (names);
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ y = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ endfunction
+ 
+ [lnames, idx] = unique (tolower (names));
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ [y, i] = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ idx = find (match);
+ if (optfirst)
+   idx += 1;
+   ## in-place is faster than other forms of increment
+ endif
+ i (idx) = [];
+ endfunction
+ 
+ if (length (lnames) < length (names))
+   ## This is bad.
+   error ("__all_opts__: duplicate options with inconsistent case");
+ else
+   names = names (idx);
+ endif
+ names = names (idx);
+ saved_names = names;
+ recursive = false;
+ endfunction
+ 
+ ## Discard result to avoid polluting workspace with ans at startup.
+ ~ = __all_opts__ ("pqpnonneg");
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ ## query all options from all known functions.  These will call optimset,
+ ## which will in turn call us, but we won't answer.
+ recursive = true;
+ names = saved_names;
+ for i = 1:nargin
+   try
+     opts = optimset (varargin {i});
+     fn = fieldnames (opts).';
+     names = [names, fn];
+   catch
+     ## throw the error as a warning.
+     warning (lasterr ());
+   end_try_catch
+ endfor
+ try
+   opts = optimset (varargin {i});
+   fn = fieldnames (opts).';
+   names = [names, fn];
+ catch
+   ## throw the error as a warning.
+   warning (lasterr ());
+ end_try_catch
+ opts = optimset (varargin {i});
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Return defaults for named function.
+ fcn = varargin {1};
+ try
+   retval = feval (fcn, "defaults");
+ catch
+   error ("optimset: no defaults for function '%s'", fcn);
+ end_try_catch
+ retval = feval (fcn, "defaults");
+ ## Copyright (C) 2008-2017 Bill Denney
+ ## Copyright (C) 2008 Jaroslav Hajek
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{x} =} pqpnonneg (@var{c}, @var{d})
+ ## @deftypefnx {} {@var{x} =} pqpnonneg (@var{c}, @var{d}, @var{x0})
+ ## @deftypefnx {} {[@var{x}, @var{minval}] =} pqpnonneg (@dots{})
+ ## @deftypefnx {} {[@var{x}, @var{minval}, @var{exitflag}] =} pqpnonneg (@dots{})
+ ## @deftypefnx {} {[@var{x}, @var{minval}, @var{exitflag}, @var{output}] =} pqpnonneg (@dots{})
+ ## @deftypefnx {} {[@var{x}, @var{minval}, @var{exitflag}, @var{output}, @var{lambda}] =} pqpnonneg (@dots{})
+ ## Minimize @code{1/2*x'*c*x + d'*x} subject to @code{@var{x} >= 0}.
+ ##
+ ## @var{c} and @var{d} must be real, and @var{c} must be symmetric and
+ ## positive definite.
+ ##
+ ## @var{x0} is an optional initial guess for @var{x}.
+ ##
+ ## Outputs:
+ ##
+ ## @itemize @bullet
+ ## @item minval
+ ##
+ ## The minimum attained model value, 1/2*xmin'*c*xmin + d'*xmin
+ ##
+ ## @item exitflag
+ ##
+ ## An indicator of convergence.  0 indicates that the iteration count was
+ ## exceeded, and therefore convergence was not reached; >0 indicates that the
+ ## algorithm converged.  (The algorithm is stable and will converge given
+ ## enough iterations.)
+ ##
+ ## @item output
+ ##
+ ## A structure with two fields:
+ ##
+ ## @itemize @bullet
+ ## @item @qcode{"algorithm"}: The algorithm used (@qcode{"nnls"})
+ ##
+ ## @item @qcode{"iterations"}: The number of iterations taken.
+ ## @end itemize
+ ##
+ ## @item lambda
+ ##
+ ## Not implemented.
+ ## @end itemize
+ ## @seealso{optimset, lsqnonneg, qp}
+ ## @end deftypefn
+ 
+ ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+ ## PKG_ADD: [~] = __all_opts__ ("pqpnonneg");
+ 
+ ## This is analogical to the lsqnonneg implementation, which is
+ ## implemented from Lawson and Hanson's 1973 algorithm on page
+ ## 161 of Solving Least Squares Problems.
+ ## It shares the convergence guarantees.
+ 
+ function [x, minval, exitflag, output, lambda] = pqpnonneg (c, d, x = [], options = struct ())
+ if (nargin == 1 && ischar (c) && strcmp (c, 'defaults'))
+   x = optimset ("MaxIter", 1e5);
+   return
+ endif
+ x = optimset ("MaxIter", 1e5);
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Create struct.
+ ## Default values are replaced by those specified by name/value pairs.
+ pairs = reshape (varargin, 2, []);
+ retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Set slots in old from non-empties in new.
+ ## Should we be checking to ensure that the field names are expected?
+ old = varargin {1};
+ new = varargin {2};
+ fnames = fieldnames (old);
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ ## skip validation if we're in the internal query
+ validation = !isempty (opts);
+ for [val, key] = new
+   if (validation)
+     ## Case insensitive lookup in all options.
+     i = strncmpi (opts, key, length (key));
+     nmatch = sum (i);
+     ## Validate option.
+     if (nmatch == 1)
+       key = opts {find (i)};
+     elseif (nmatch == 0)
+       warning ("optimset: unrecognized option: %s", key);
+     else
+       fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+       warning (fmt, key, opts {i});
+     endif
+   endif
+   old. = val;
+ endfor
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ retval = old;
+ endfunction
+ 
+ endfunction
+ 
+ return
+ 
+ endfunction
+ 
+ fn = fieldnames (opts).';
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ names = [names, fn];
+ names = unique (names);
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ y = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ endfunction
+ 
+ [lnames, idx] = unique (tolower (names));
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ [y, i] = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ idx = find (match);
+ if (optfirst)
+   idx += 1;
+   ## in-place is faster than other forms of increment
+ endif
+ i (idx) = [];
+ endfunction
+ 
+ if (length (lnames) < length (names))
+   ## This is bad.
+   error ("__all_opts__: duplicate options with inconsistent case");
+ else
+   names = names (idx);
+ endif
+ names = names (idx);
+ saved_names = names;
+ recursive = false;
+ endfunction
+ 
+ ## Discard result to avoid polluting workspace with ans at startup.
+ ~ = __all_opts__ ("qp");
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ ## query all options from all known functions.  These will call optimset,
+ ## which will in turn call us, but we won't answer.
+ recursive = true;
+ names = saved_names;
+ for i = 1:nargin
+   try
+     opts = optimset (varargin {i});
+     fn = fieldnames (opts).';
+     names = [names, fn];
+   catch
+     ## throw the error as a warning.
+     warning (lasterr ());
+   end_try_catch
+ endfor
+ try
+   opts = optimset (varargin {i});
+   fn = fieldnames (opts).';
+   names = [names, fn];
+ catch
+   ## throw the error as a warning.
+   warning (lasterr ());
+ end_try_catch
+ opts = optimset (varargin {i});
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Return defaults for named function.
+ fcn = varargin {1};
+ try
+   retval = feval (fcn, "defaults");
+ catch
+   error ("optimset: no defaults for function '%s'", fcn);
+ end_try_catch
+ retval = feval (fcn, "defaults");
+ ## Copyright (C) 2013-2017 Julien Bect
+ ## Copyright (C) 2000-2016 Gabriele Pannocchia.
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H})
+ ## @deftypefnx {} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H}, @var{q})
+ ## @deftypefnx {} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H}, @var{q}, @var{A}, @var{b})
+ ## @deftypefnx {} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H}, @var{q}, @var{A}, @var{b}, @var{lb}, @var{ub})
+ ## @deftypefnx {} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H}, @var{q}, @var{A}, @var{b}, @var{lb}, @var{ub}, @var{A_lb}, @var{A_in}, @var{A_ub})
+ ## @deftypefnx {} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@dots{}, @var{options})
+ ## Solve a quadratic program (QP).
+ ##
+ ## Solve the quadratic program defined by
+ ## @tex
+ ## $$
+ ##  \min_x {1 \over 2} x^T H x + x^T q
+ ## $$
+ ## @end tex
+ ## @ifnottex
+ ##
+ ## @example
+ ## @group
+ ## min 0.5 x'*H*x + x'*q
+ ##  x
+ ## @end group
+ ## @end example
+ ##
+ ## @end ifnottex
+ ## subject to
+ ## @tex
+ ## $$
+ ##  A x = b \qquad lb \leq x \leq ub \qquad A_{lb} \leq A_{in} x \leq A_{ub}
+ ## $$
+ ## @end tex
+ ## @ifnottex
+ ##
+ ## @example
+ ## @group
+ ## A*x = b
+ ## lb <= x <= ub
+ ## A_lb <= A_in*x <= A_ub
+ ## @end group
+ ## @end example
+ ##
+ ## @end ifnottex
+ ## @noindent
+ ## using a null-space active-set method.
+ ##
+ ## Any bound (@var{A}, @var{b}, @var{lb}, @var{ub}, @var{A_in}, @var{A_lb},
+ ## @var{A_ub}) may be set to the empty matrix (@code{[]}) if not present.  The
+ ## constraints @var{A} and @var{A_in} are matrices with each row representing
+ ## a single constraint.  The other bounds are scalars or vectors depending on
+ ## the number of constraints.  The algorithm is faster if the initial guess is
+ ## feasible.
+ ##
+ ## @table @var
+ ## @item options
+ ## An optional structure containing the following parameter(s) used to define
+ ## the behavior of the solver.  Missing elements in the structure take on
+ ## default values, so you only need to set the elements that you wish to
+ ## change from the default.
+ ##
+ ## @table @code
+ ## @item MaxIter (default: 200)
+ ## Maximum number of iterations.
+ ## @end table
+ ## @end table
+ ##
+ ## @table @var
+ ## @item info
+ ## Structure containing run-time information about the algorithm.  The
+ ## following fields are defined:
+ ##
+ ## @table @code
+ ## @item solveiter
+ ## The number of iterations required to find the solution.
+ ##
+ ## @item info
+ ## An integer indicating the status of the solution.
+ ##
+ ## @table @asis
+ ## @item 0
+ ## The problem is feasible and convex.  Global solution found.
+ ##
+ ## @item 1
+ ## The problem is not convex.  Local solution found.
+ ##
+ ## @item 2
+ ## The problem is not convex and unbounded.
+ ##
+ ## @item 3
+ ## Maximum number of iterations reached.
+ ##
+ ## @item 6
+ ## The problem is infeasible.
+ ## @end table
+ ## @end table
+ ## @end table
+ ## @end deftypefn
+ 
+ ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
+ ## PKG_ADD: [~] = __all_opts__ ("qp");
+ 
+ function [x, obj, INFO, lambda] = qp (x0, H, varargin)
+ if (nargin == 1 && ischar (x0) && strcmp (x0, "defaults"))
+   x = optimset ("MaxIter", 200);
+   return
+ endif
+ x = optimset ("MaxIter", 200);
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Create struct.
+ ## Default values are replaced by those specified by name/value pairs.
+ pairs = reshape (varargin, 2, []);
+ retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ ## Copyright (C) 2007-2017 John W. Eaton
+ ## Copyright (C) 2009 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset ()
+ ## @deftypefnx {} {@var{options} =} optimset (@var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{par}, @var{val}, @dots{})
+ ## @deftypefnx {} {@var{options} =} optimset (@var{old}, @var{new})
+ ## Create options structure for optimization functions.
+ ##
+ ## When called without any input or output arguments, @code{optimset} prints
+ ## a list of all valid optimization parameters.
+ ##
+ ## When called with one output and no inputs, return an options structure with
+ ## all valid option parameters initialized to @code{[]}.
+ ##
+ ## When called with a list of parameter/value pairs, return an options
+ ## structure with only the named parameters initialized.
+ ##
+ ## When the first input is an existing options structure @var{old}, the values
+ ## are updated from either the @var{par}/@var{val} list or from the options
+ ## structure @var{new}.
+ ##
+ ## Valid parameters are:
+ ##
+ ## @table @asis
+ ## @item AutoScaling
+ ##
+ ## @item ComplexEqn
+ ##
+ ## @item Display
+ ## Request verbose display of results from optimizations.  Values are:
+ ##
+ ## @table @asis
+ ## @item @qcode{"off"} [default]
+ ## No display.
+ ##
+ ## @item @qcode{"iter"}
+ ## Display intermediate results for every loop iteration.
+ ##
+ ## @item @qcode{"final"}
+ ## Display the result of the final loop iteration.
+ ##
+ ## @item @qcode{"notify"}
+ ## Display the result of the final loop iteration if the function has
+ ## failed to converge.
+ ## @end table
+ ##
+ ## @item FinDiffType
+ ##
+ ## @item FunValCheck
+ ## When enabled, display an error if the objective function returns an invalid
+ ## value (a complex number, NaN, or Inf).  Must be set to @qcode{"on"} or
+ ## @qcode{"off"} [default].  Note: the functions @code{fzero} and
+ ## @code{fminbnd} correctly handle Inf values and only complex values or NaN
+ ## will cause an error in this case.
+ ##
+ ## @item GradObj
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the gradient, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## gradient is computed via finite differences.
+ ##
+ ## @item Jacobian
+ ## When set to @qcode{"on"}, the function to be minimized must return a
+ ## second argument which is the Jacobian, or first derivative, of the
+ ## function at the point @var{x}.  If set to @qcode{"off"} [default], the
+ ## Jacobian is computed via finite differences.
+ ##
+ ## @item MaxFunEvals
+ ## Maximum number of function evaluations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item MaxIter
+ ## Maximum number of algorithm iterations before optimization stops.
+ ## Must be a positive integer.
+ ##
+ ## @item OutputFcn
+ ## A user-defined function executed once per algorithm iteration.
+ ##
+ ## @item TolFun
+ ## Termination criterion for the function output.  If the difference in the
+ ## calculated objective function between one algorithm iteration and the next
+ ## is less than @code{TolFun} the optimization stops.  Must be a positive
+ ## scalar.
+ ##
+ ## @item TolX
+ ## Termination criterion for the function input.  If the difference in @var{x},
+ ## the current search point, between one algorithm iteration and the next is
+ ## less than @code{TolX} the optimization stops.  Must be a positive scalar.
+ ##
+ ## @item TypicalX
+ ##
+ ## @item Updating
+ ## @end table
+ ## @seealso{optimget}
+ ## @end deftypefn
+ 
+ function retval = optimset (varargin)
+ nargs = nargin;
+ opts = __all_opts__ ();
+ ## Copyright (C) 2009-2017 VZLU Prague
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {@var{names} =} __all_opts__ (@dots{})
+ ## Undocumented internal function.
+ ## @end deftypefn
+ 
+ ## Query all options from all known optimization functions and return a
+ ## list of possible values.
+ 
+ function names = __all_opts__ (varargin)
+ persistent saved_names = {}(0x0)

+ ## do not clear this function
+ mlock ();
+ ## guard against recursive calls.
+ persistent recursive = false
+ if (recursive)
+   names = {}(0x0)
;
+ elseif (nargin == 0)
+   names = saved_names;
+ else
+   ## query all options from all known functions.  These will call optimset,
+   ## which will in turn call us, but we won't answer.
+   recursive = true;
+   names = saved_names;
+   for i = 1:nargin
+     try
+       opts = optimset (varargin {i});
+       fn = fieldnames (opts).';
+       names = [names, fn];
+     catch
+       ## throw the error as a warning.
+       warning (lasterr ());
+     end_try_catch
+   endfor
+   names = unique (names);
+   [lnames, idx] = unique (tolower (names));
+   if (length (lnames) < length (names))
+     ## This is bad.
+     error ("__all_opts__: duplicate options with inconsistent case");
+   else
+     names = names (idx);
+   endif
+   saved_names = names;
+   recursive = false;
+ endif
+ names = {}(0x0)
;
+ endfunction
+ 
+ if (nargs == 0)
+   if (nargout == 0)
+     ## Display possibilities.
+     puts ("\nAll possible optimization options:\n\n");
+     printf ("  %s\n", opts {:});
+     puts ("\n");
+   else
+     ## Return struct with all options initialized to []
+     retval = cell2struct (repmat ({[]}, size (opts)), opts, 2);
+   endif
+ elseif (nargs == 1 && ischar (varargin {1}))
+   ## Return defaults for named function.
+   fcn = varargin {1};
+   try
+     retval = feval (fcn, "defaults");
+   catch
+     error ("optimset: no defaults for function '%s'", fcn);
+   end_try_catch
+ elseif (nargs == 2 && isstruct (varargin {1}) && isstruct (varargin {2}))
+   ## Set slots in old from non-empties in new.
+   ## Should we be checking to ensure that the field names are expected?
+   old = varargin {1};
+   new = varargin {2};
+   fnames = fieldnames (old);
+   ## skip validation if we're in the internal query
+   validation = !isempty (opts);
+   for [val, key] = new
+     if (validation)
+       ## Case insensitive lookup in all options.
+       i = strncmpi (opts, key, length (key));
+       nmatch = sum (i);
+       ## Validate option.
+       if (nmatch == 1)
+         key = opts {find (i)};
+       elseif (nmatch == 0)
+         warning ("optimset: unrecognized option: %s", key);
+       else
+         fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+         warning (fmt, key, opts {i});
+       endif
+     endif
+     old. = val;
+   endfor
+   retval = old;
+ elseif (rem (nargs, 2) && isstruct (varargin {1}))
+   ## Set values in old from name/value pairs.
+   pairs = reshape (varargin (2:end), 2, []);
+   retval = optimset (varargin {1}, cell2struct (pairs (2, :), pairs (1, :), 2));
+ elseif (rem (nargs, 2) == 0)
+   ## Create struct.
+   ## Default values are replaced by those specified by name/value pairs.
+   pairs = reshape (varargin, 2, []);
+   retval = optimset (struct (), cell2struct (pairs (2, :), pairs (1, :), 2));
+ else
+   print_usage ();
+ endif
+ ## Set slots in old from non-empties in new.
+ ## Should we be checking to ensure that the field names are expected?
+ old = varargin {1};
+ new = varargin {2};
+ fnames = fieldnames (old);
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ ## skip validation if we're in the internal query
+ validation = !isempty (opts);
+ for [val, key] = new
+   if (validation)
+     ## Case insensitive lookup in all options.
+     i = strncmpi (opts, key, length (key));
+     nmatch = sum (i);
+     ## Validate option.
+     if (nmatch == 1)
+       key = opts {find (i)};
+     elseif (nmatch == 0)
+       warning ("optimset: unrecognized option: %s", key);
+     else
+       fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+       warning (fmt, key, opts {i});
+     endif
+   endif
+   old. = val;
+ endfor
+ if (validation)
+   ## Case insensitive lookup in all options.
+   i = strncmpi (opts, key, length (key));
+   nmatch = sum (i);
+   ## Validate option.
+   if (nmatch == 1)
+     key = opts {find (i)};
+   elseif (nmatch == 0)
+     warning ("optimset: unrecognized option: %s", key);
+   else
+     fmt = sprintf ("optimset: ambiguous option: %%s (%s%%s)", repmat ("%s, ", 1, nmatch - 1));
+     warning (fmt, key, opts {i});
+   endif
+ endif
+ old. = val;
+ retval = old;
+ endfunction
+ 
+ endfunction
+ 
+ return
+ 
+ endfunction
+ 
+ fn = fieldnames (opts).';
+ ## Copyright (C) 2012-2017 Rik Wehbring
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {@var{names} =} fieldnames (@var{struct})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{obj})
+ ## @deftypefnx {} {@var{names} =} fieldnames (@var{javaobj})
+ ## @deftypefnx {} {@var{names} =} fieldnames ("@var{javaclassname}")
+ ## Return a cell array of strings with the names of the fields in the
+ ## specified input.
+ ##
+ ## When the input is a structure @var{struct}, the names are the elements of
+ ## the structure.
+ ##
+ ## When the input is an Octave object @var{obj}, the names are the public
+ ## properties of the object.
+ ##
+ ## When the input is a Java object @var{javaobj} or a string containing the
+ ## name of a Java class @var{javaclassname}, the names are the public fields
+ ## (data members) of the object or class.
+ ## @seealso{numfields, isfield, orderfields, struct, methods}
+ ## @end deftypefn
+ 
+ function names = fieldnames (obj)
+ if (nargin != 1)
+   print_usage ();
+ endif
+ if (isstruct (obj) || isobject (obj))
+   ## Call internal C++ function for structs or Octave objects
+   names = __fieldnames__ (obj);
+ elseif (isjava (obj) || ischar (obj))
+   ## FIXME: Function prototype that accepts java obj exists, but doesn't
+   ##        work if obj is java.lang.String.  Convert obj to classname.
+   ## FIXME: this is now working for objects whose class is in the dynamic
+   ##        classpath but will continue to fail if such classnames are used
+   ##        instead (see bug #42710).
+   if (isa (obj, "java.lang.String"))
+     obj = class (obj);
+   endif
+   names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+   names = ostrsplit (names_str, ';');
+ else
+   error ("fieldnames: Invalid input argument");
+ endif
+ ## Call internal C++ function for structs or Octave objects
+ names = __fieldnames__ (obj);
+ endfunction
+ 
+ names = [names, fn];
+ names = unique (names);
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ y = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ endfunction
+ 
+ [lnames, idx] = unique (tolower (names));
+ ## Copyright (C) 2000-2017 Paul Kienzle
+ ## Copyright (C) 2008-2009 Jaroslav Hajek
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn  {} {} unique (@var{x})
+ ## @deftypefnx {} {} unique (@var{x}, "rows")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "first")
+ ## @deftypefnx {} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{}, "last")
+ ## Return the unique elements of @var{x} sorted in ascending order.
+ ##
+ ## If the input @var{x} is a column vector then return a column vector;
+ ## Otherwise, return a row vector.  @var{x} may also be a cell array of
+ ## strings.
+ ##
+ ## If the optional argument @qcode{"rows"} is given then return the unique
+ ## rows of @var{x} sorted in ascending order.  The input must be a 2-D matrix
+ ## to use this option.
+ ##
+ ## If requested, return index vectors @var{i} and @var{j} such that
+ ## @code{@var{y} = @var{x}(@var{i})} and @code{@var{x} = @var{y}(@var{j})}.
+ ##
+ ## Additionally, if @var{i} is a requested output then one of
+ ## @qcode{"first"} or @qcode{"last"} may be given as an input.  If
+ ## @qcode{"last"} is specified, return the highest possible indices in
+ ## @var{i}, otherwise, if @qcode{"first"} is specified, return the lowest.
+ ## The default is @qcode{"last"}.
+ ## @seealso{union, intersect, setdiff, setxor, ismember}
+ ## @end deftypefn
+ 
+ function [y, i, j] = unique (x, varargin)
+ if (nargin < 1)
+   print_usage ();
+ elseif (!(isnumeric (x) || islogical (x) || ischar (x) || iscellstr (x)))
+   error ("unique: X must be an array or cell array of strings");
+ endif
+ if (nargin > 1)
+   ## parse options
+   if (!iscellstr (varargin))
+     error ("unique: options must be strings");
+   endif
+   optrows = any (strcmp ("rows", varargin));
+   optfirst = any (strcmp ("first", varargin));
+   optlast = any (strcmp ("last", varargin));
+   if (optfirst && optlast)
+     error ('unique: cannot specify both "first" and "last"');
+   elseif (optfirst + optlast + optrows != nargin - 1)
+     error ("unique: invalid option");
+   endif
+   if (optrows && iscellstr (x))
+     warning ('unique: "rows" is ignored for cell arrays');
+     optrows = false;
+   endif
+ else
+   optrows = false;
+   optfirst = false;
+ endif
+ optrows = false;
+ optfirst = false;
+ ## FIXME: The operations
+ ##
+ ##   match = (y(1:n-1) == y(2:n));
+ ##   y(idx) = [];
+ ##
+ ## are very slow on sparse matrices.  Until they are fixed to be as
+ ## fast as for full matrices, operate on the nonzero elements of the
+ ## sparse array as long as we are not operating on rows.
+ if (issparse (x) && !optrows && nargout <= 1)
+   if (nnz (x) < numel (x))
+     y = unique ([0; nonzeros(x)], varargin {:});
+   else
+     ## Corner case where sparse matrix is actually full
+     y = unique (full (x), varargin {:});
+   endif
+   return
+ endif
+ if (optrows)
+   n = rows (x);
+   dim = 1;
+ else
+   n = numel (x);
+   dim = (rows (x) == 1) + 1;
+ endif
+ n = numel (x);
+ dim = (rows (x) == 1) + 1;
+ y = x;
+ ## Special cases 0 and 1
+ if (n == 0)
+   if (!optrows && isempty (x) && any (size (x)))
+     if (iscellstr (y))
+       y = cell (0, 1);
+     else
+       y = zeros (0, 1, class (y));
+     endif
+   endif
+   i = j = [];
+   return
+ elseif (n == 1)
+   i = j = 1;
+   return
+ endif
+ if (optrows)
+   if (nargout > 1)
+     [y, i] = sortrows (y);
+   else
+     y = sortrows (y);
+   endif
+   match = all (y (1:n - 1, :) == y (2:n, :), 2);
+   y (match, :) = [];
+ else
+   if (!isvector (y))
+     y = y (:);
+   endif
+   if (nargout > 1)
+     [y, i] = sort (y);
+   else
+     y = sort (y);
+   endif
+   if (iscellstr (y))
+     match = strcmp (y (1:n - 1), y (2:n));
+   else
+     match = (y (1:n - 1) == y (2:n));
+   endif
+   y (match) = [];
+ endif
+ if (!isvector (y))
+   y = y (:);
+ endif
+ if (nargout > 1)
+   [y, i] = sort (y);
+ else
+   y = sort (y);
+ endif
+ [y, i] = sort (y);
+ if (iscellstr (y))
+   match = strcmp (y (1:n - 1), y (2:n));
+ else
+   match = (y (1:n - 1) == y (2:n));
+ endif
+ match = strcmp (y (1:n - 1), y (2:n));
+ y (match) = [];
+ if (isargout (3))
+   j = i;
+   if (dim == 1)
+     j (i) = cumsum ([1; !match]);
+   else
+     j (i) = cumsum ([1, !match]);
+   endif
+ endif
+ if (isargout (2))
+   idx = find (match);
+   if (optfirst)
+     idx += 1;
+     ## in-place is faster than other forms of increment
+   endif
+   i (idx) = [];
+ endif
+ idx = find (match);
+ if (optfirst)
+   idx += 1;
+   ## in-place is faster than other forms of increment
+ endif
+ i (idx) = [];
+ endfunction
+ 
+ if (length (lnames) < length (names))
+   ## This is bad.
+   error ("__all_opts__: duplicate options with inconsistent case");
+ else
+   names = names (idx);
+ endif
+ names = names (idx);
+ saved_names = names;
+ recursive = false;
+ endfunction
+ 
+ endscript
+ ## System-wide startup file for Octave.
+ ##
+ ## If the environment variable OCTAVE_SITE_INITFILE is set when Octave
+ ## starts, then that file is executed instead of this file.
+ ##
+ ## This file contain commands that should be executed each time Octave starts
+ ## for every user at this site.
+ endscript
+ ## System-wide startup file for Octave.
+ ##
+ ## This file should contain any commands that should be executed each
+ ## time Octave starts for every user at this site.
+ 
+ ## This file is an extended copy of Octave's startup file at
+ ## /usr/share/octave/${OCTAVE_VERSION}/m/startup/octaverc
+ ## Configure readline using the file inputrc in the Octave startup
+ ## directory.
+ readline_read_init_file (sprintf ("%s%s%s", __octave_config_info__ ("startupfiledir"), filesep, "inputrc"));
+ if (strcmp (PAGER (), "less") && isempty (getenv ("LESS")))
+   PAGER_FLAGS ('-e -X -P"-- less ?pB(%pB\\%):--. (f)orward, (b)ack, (q)uit$"');
+ endif
+ PAGER_FLAGS ('-e -X -P"-- less ?pB(%pB\\%):--. (f)orward, (b)ack, (q)uit$"');
+ ## This appears here instead of in the pkg/PKG_ADD file so that --norc
+ ## will also skip automatic loading of packages.
+ atexit ("__finish__");
+ ## Set the Debian-specific error handler
+ missing_component_hook ("debian_missing_handler");
+ endscript
+ ## Octave program
+ 
+ ## This is the solution to the particular set of equality constraints
+ ## that gives the cost-minimization problem in Meadows or Malls
+ 
+ ## x = [ GR AR MR GD AD MD ]
+ c = [50, 200, 100, 500, 2000, 1000]
c =

     50    200    100    500   2000   1000

+ A = [1, 0, 0, 1, 0, 0; 0, 1, 0, 0, 1, 0; 0, 0, 1, 0, 0, 1; 0, 0, 0, 1, 1, 1; 0, 0, 1, 0, 0, 0; 0, 1, 0, 1, 0, 0]
A =

   1   0   0   1   0   0
   0   1   0   0   1   0
   0   0   1   0   0   1
   0   0   0   1   1   1
   0   0   1   0   0   0
   0   1   0   1   0   0

+ b = [300, 100, 150, 300, 0, 100]'
b =

   300
   100
   150
   300
     0
   100

+ ## Solve by inverting A
+ A_1 = inv (A)
A_1 =

   1.00000   0.50000   0.50000  -0.50000  -0.50000  -0.50000
   0.00000   0.50000   0.50000  -0.50000  -0.50000   0.50000
   0.00000   0.00000   0.00000  -0.00000   1.00000   0.00000
   0.00000  -0.50000  -0.50000   0.50000   0.50000   0.50000
   0.00000   0.50000  -0.50000   0.50000   0.50000  -0.50000
   0.00000   0.00000   1.00000   0.00000  -1.00000   0.00000

+ A_1 * b
ans =

   225
    25
     0
    75
    75
   150

+ ## Solve by row operations on the augmented matrix 
+ A_aug = [A, b]
A_aug =

     1     0     0     1     0     0   300
     0     1     0     0     1     0   100
     0     0     1     0     0     1   150
     0     0     0     1     1     1   300
     0     0     1     0     0     0     0
     0     1     0     1     0     0   100

+ ## Replace row 6 with row 6 less row 2
+ A_aug (6, :) = A_aug (6, :) - A_aug (2, :)
A_aug =

     1     0     0     1     0     0   300
     0     1     0     0     1     0   100
     0     0     1     0     0     1   150
     0     0     0     1     1     1   300
     0     0     1     0     0     0     0
     0     0     0     1    -1     0     0

+ ## Switch rows 3 and 5
+ A_aug ([3, 5], :) = A_aug ([5, 3], :)
A_aug =

     1     0     0     1     0     0   300
     0     1     0     0     1     0   100
     0     0     1     0     0     0     0
     0     0     0     1     1     1   300
     0     0     1     0     0     1   150
     0     0     0     1    -1     0     0

+ ## Replace row 5 with row 5 less row 3
+ A_aug (5, :) = A_aug (5, :) - A_aug (3, :)
A_aug =

     1     0     0     1     0     0   300
     0     1     0     0     1     0   100
     0     0     1     0     0     0     0
     0     0     0     1     1     1   300
     0     0     0     0     0     1   150
     0     0     0     1    -1     0     0

+ ## Replace row 6 with row 6 less row 4
+ A_aug (6, :) = A_aug (6, :) - A_aug (4, :)
A_aug =

     1     0     0     1     0     0   300
     0     1     0     0     1     0   100
     0     0     1     0     0     0     0
     0     0     0     1     1     1   300
     0     0     0     0     0     1   150
     0     0     0     0    -2    -1  -300

+ ## Switch rows 5 and 6
+ A_aug ([5, 6], :) = A_aug ([6, 5], :)
A_aug =

     1     0     0     1     0     0   300
     0     1     0     0     1     0   100
     0     0     1     0     0     0     0
     0     0     0     1     1     1   300
     0     0     0     0    -2    -1  -300
     0     0     0     0     0     1   150

+ ## Divide row 5 by -2
+ A_aug (5, :) = A_aug (5, :) / -2
A_aug =

 Columns 1 through 6:

     1.00000     0.00000     0.00000     1.00000     0.00000     0.00000
     0.00000     1.00000     0.00000     0.00000     1.00000     0.00000
     0.00000     0.00000     1.00000     0.00000     0.00000     0.00000
     0.00000     0.00000     0.00000     1.00000     1.00000     1.00000
    -0.00000    -0.00000    -0.00000    -0.00000     1.00000     0.50000
     0.00000     0.00000     0.00000     0.00000     0.00000     1.00000

 Column 7:

   300.00000
   100.00000
     0.00000
   300.00000
   150.00000
   150.00000

+ ## The matrix is now upper triangular and I could solve by substitution.
+ ## Or continue with row operations
+ 
+ ## Replace row 5 with row 5 less one half of row 6 
+ A_aug (5, :) = A_aug (5, :) - A_aug (6, :) / (2)
A_aug =

     1     0     0     1     0     0   300
     0     1     0     0     1     0   100
     0     0     1     0     0     0     0
     0     0     0     1     1     1   300
    -0    -0    -0    -0     1     0    75
     0     0     0     0     0     1   150

+ ## Replace row 4 with row 4 less row 6 and then subtract row 5
+ A_aug (4, :) = A_aug (4, :) - A_aug (6, :) - A_aug (5, :)
A_aug =

     1     0     0     1     0     0   300
     0     1     0     0     1     0   100
     0     0     1     0     0     0     0
     0     0     0     1     0     0    75
    -0    -0    -0    -0     1     0    75
     0     0     0     0     0     1   150

+ ## Replace row 2 with row 2 less row 5
+ A_aug (2, :) = A_aug (2, :) - A_aug (5, :)
A_aug =

     1     0     0     1     0     0   300
     0     1     0     0     0     0    25
     0     0     1     0     0     0     0
     0     0     0     1     0     0    75
    -0    -0    -0    -0     1     0    75
     0     0     0     0     0     1   150

+ ## Replace row 1 with row 1 less row 4
+ A_aug (1, :) = A_aug (1, :) - A_aug (4, :)
A_aug =

     1     0     0     0     0     0   225
     0     1     0     0     0     0    25
     0     0     1     0     0     0     0
     0     0     0     1     0     0    75
    -0    -0    -0    -0     1     0    75
     0     0     0     0     0     1   150

+ ## Compute the cost of this solution
+ dot (c, A_aug (:, 7))
ans =  353750
+ endscript
+ ## Copyright (C) 2008-2017 Ben Abbott
+ ##
+ ## This file is part of Octave.
+ ##
+ ## Octave is free software; you can redistribute it and/or modify it
+ ## under the terms of the GNU General Public License as published by
+ ## the Free Software Foundation; either version 3 of the License, or (at
+ ## your option) any later version.
+ ##
+ ## Octave is distributed in the hope that it will be useful, but
+ ## WITHOUT ANY WARRANTY; without even the implied warranty of
+ ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ ## General Public License for more details.
+ ##
+ ## You should have received a copy of the GNU General Public License
+ ## along with Octave; see the file COPYING.  If not, see
+ ## <http://www.gnu.org/licenses/>.
+ 
+ ## -*- texinfo -*-
+ ## @deftypefn {} {} __finish__
+ ## Check for the existence of the function/script, @file{finish}, in the
+ ## path or current working directory and execute it.
+ ##
+ ## This function is intended to be executed upon a clean exit from Octave.
+ ## This is accomplished in the system script @file{startup/octaverc} by use of
+ ## the built-in function @code{atexit}.
+ ## @seealso{atexit}
+ ## @end deftypefn
+ 
+ ## No function declaration, this is an Octave script.  This means we are
+ ## still in the base workspace with access to all user variables.
+ if (exist ("finish", "file"))
+   finish;
+   ## No arg list here since finish might be a script.
+ endif
+ ## No test needed for internal helper m-file.
+ ##!assert (1)
+ endscript
